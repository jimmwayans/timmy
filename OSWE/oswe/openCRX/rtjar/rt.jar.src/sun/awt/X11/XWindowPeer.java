/*      */ package sun.awt.X11;
/*      */ 
/*      */ import java.awt.Color;
/*      */ import java.awt.Component;
/*      */ import java.awt.Dialog;
/*      */ import java.awt.Dimension;
/*      */ import java.awt.EventQueue;
/*      */ import java.awt.Font;
/*      */ import java.awt.Graphics;
/*      */ import java.awt.GraphicsConfiguration;
/*      */ import java.awt.GraphicsDevice;
/*      */ import java.awt.GraphicsEnvironment;
/*      */ import java.awt.Image;
/*      */ import java.awt.Insets;
/*      */ import java.awt.Point;
/*      */ import java.awt.Rectangle;
/*      */ import java.awt.Shape;
/*      */ import java.awt.SystemColor;
/*      */ import java.awt.Window;
/*      */ import java.awt.event.ComponentEvent;
/*      */ import java.awt.event.WindowEvent;
/*      */ import java.awt.geom.AffineTransform;
/*      */ import java.awt.peer.ComponentPeer;
/*      */ import java.awt.peer.WindowPeer;
/*      */ import java.io.UnsupportedEncodingException;
/*      */ import java.security.AccessController;
/*      */ import java.security.PrivilegedAction;
/*      */ import java.util.ArrayList;
/*      */ import java.util.HashSet;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Set;
/*      */ import java.util.Vector;
/*      */ import java.util.concurrent.atomic.AtomicBoolean;
/*      */ import sun.awt.AWTAccessor;
/*      */ import sun.awt.AWTIcon32_java_icon16_png;
/*      */ import sun.awt.AWTIcon32_java_icon24_png;
/*      */ import sun.awt.AWTIcon32_java_icon32_png;
/*      */ import sun.awt.AWTIcon32_java_icon48_png;
/*      */ import sun.awt.AWTIcon64_java_icon16_png;
/*      */ import sun.awt.AWTIcon64_java_icon24_png;
/*      */ import sun.awt.AWTIcon64_java_icon32_png;
/*      */ import sun.awt.AWTIcon64_java_icon48_png;
/*      */ import sun.awt.DisplayChangedListener;
/*      */ import sun.awt.IconInfo;
/*      */ import sun.awt.SunToolkit;
/*      */ import sun.awt.UngrabEvent;
/*      */ import sun.awt.X11GraphicsDevice;
/*      */ import sun.awt.X11GraphicsEnvironment;
/*      */ import sun.java2d.pipe.Region;
/*      */ import sun.util.logging.PlatformLogger;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ class XWindowPeer
/*      */   extends XPanelPeer
/*      */   implements WindowPeer, DisplayChangedListener
/*      */ {
/*   63 */   private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.X11.XWindowPeer");
/*   64 */   private static final PlatformLogger focusLog = PlatformLogger.getLogger("sun.awt.X11.focus.XWindowPeer");
/*   65 */   private static final PlatformLogger insLog = PlatformLogger.getLogger("sun.awt.X11.insets.XWindowPeer");
/*   66 */   private static final PlatformLogger grabLog = PlatformLogger.getLogger("sun.awt.X11.grab.XWindowPeer");
/*   67 */   private static final PlatformLogger iconLog = PlatformLogger.getLogger("sun.awt.X11.icon.XWindowPeer");
/*      */ 
/*      */   
/*   70 */   private static Set<XWindowPeer> windows = new HashSet<>();
/*      */   
/*      */   private boolean cachedFocusableWindow;
/*      */   
/*      */   XWarningWindow warningWindow;
/*      */   
/*      */   private boolean alwaysOnTop;
/*      */   
/*      */   private boolean locationByPlatform;
/*      */   Dialog modalBlocker;
/*      */   boolean delayedModalBlocking = false;
/*   81 */   Dimension targetMinimumSize = null;
/*      */   
/*      */   private XWindowPeer ownerPeer;
/*      */   
/*      */   protected XWindowPeer prevTransientFor;
/*      */   
/*      */   protected XWindowPeer nextTransientFor;
/*      */   
/*      */   private XWindowPeer curRealTransientFor;
/*      */   
/*      */   private boolean grab = false;
/*      */   private boolean isMapped = false;
/*      */   private boolean mustControlStackPosition = false;
/*   94 */   private XEventDispatcher rootPropertyEventDispatcher = null;
/*      */   
/*   96 */   private static final AtomicBoolean isStartupNotificationRemoved = new AtomicBoolean();
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean isUnhiding = false;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean isBeforeFirstMapNotify = false;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  111 */   private Window.Type windowType = Window.Type.NORMAL;
/*      */   
/*      */   public final Window.Type getWindowType() {
/*  114 */     return this.windowType;
/*      */   }
/*      */ 
/*      */   
/*  118 */   protected Vector<ToplevelStateListener> toplevelStateListeners = new Vector<>(); private static final int PREFERRED_SIZE_FOR_ICON = 128; private static final int MAXIMUM_BUFFER_LENGTH_NET_WM_ICON = 65535; private static ArrayList<IconInfo> defaultIconInfo; private int dropTargetCount; XAtom XA_NET_WM_STATE; XAtomList net_wm_state; private XBaseWindow pressTarget;
/*      */   
/*  120 */   XWindowPeer(XCreateWindowParams paramXCreateWindowParams) { super(paramXCreateWindowParams.putIfNull("parent window", Long.valueOf(0L)));
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 2002 */     this.dropTargetCount = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 2202 */     this.pressTarget = this; } void preInit(XCreateWindowParams paramXCreateWindowParams) { this.target = (Component)paramXCreateWindowParams.get("target"); this.windowType = ((Window)this.target).getType(); paramXCreateWindowParams.put((K)"reparented", (V)Boolean.valueOf((isOverrideRedirect() || isSimpleWindow()))); super.preInit(paramXCreateWindowParams); paramXCreateWindowParams.putIfNull("bit gravity", Integer.valueOf(1)); long l = 0L; if (paramXCreateWindowParams.containsKey("event mask")) l = ((Long)paramXCreateWindowParams.get("event mask")).longValue();  l |= 0x10000L; paramXCreateWindowParams.put((K)"event mask", (V)Long.valueOf(l)); this.XA_NET_WM_STATE = XAtom.get("_NET_WM_STATE"); paramXCreateWindowParams.put((K)"overrideRedirect", (V)Boolean.valueOf(isOverrideRedirect())); SunToolkit.awtLock(); try { windows.add(this); } finally { SunToolkit.awtUnlock(); }  this.cachedFocusableWindow = isFocusableWindow(); Font font = this.target.getFont(); if (font == null) { font = XWindow.getDefaultFont(); this.target.setFont(font); }  Color color = this.target.getBackground(); if (color == null) { SystemColor systemColor = SystemColor.window; this.target.setBackground(systemColor); }  color = this.target.getForeground(); if (color == null) this.target.setForeground(SystemColor.windowText);  this.alwaysOnTop = (((Window)this.target).isAlwaysOnTop() && ((Window)this.target).isAlwaysOnTopSupported()); GraphicsConfiguration graphicsConfiguration = getGraphicsConfiguration(); ((X11GraphicsDevice)graphicsConfiguration.getDevice()).addDisplayChangedListener(this); } protected String getWMName() { String str = this.target.getName(); if (str == null || str.trim().equals("")) str = " ";  return str; } private static native String getLocalHostname(); private static native int getJvmPID(); void postInit(XCreateWindowParams paramXCreateWindowParams) { super.postInit(paramXCreateWindowParams); initWMProtocols(); XAtom.get("WM_CLIENT_MACHINE").setProperty(getWindow(), getLocalHostname()); XAtom.get("_NET_WM_PID").setCard32Property(getWindow(), getJvmPID()); Window window1 = (Window)this.target; Window window2 = window1.getOwner(); if (window2 != null) { this.ownerPeer = (XWindowPeer)window2.getPeer(); if (focusLog.isLoggable(PlatformLogger.Level.FINER)) { focusLog.finer("Owner is " + window2); focusLog.finer("Owner peer is " + this.ownerPeer); focusLog.finer("Owner X window " + Long.toHexString(this.ownerPeer.getWindow())); focusLog.finer("Owner content X window " + Long.toHexString(this.ownerPeer.getContentWindow())); }  long l = this.ownerPeer.getWindow(); if (l != 0L) { XToolkit.awtLock(); try { if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("Setting transient on " + Long.toHexString(getWindow()) + " for " + Long.toHexString(l));  setToplevelTransientFor(this, this.ownerPeer, false, true); XWMHints xWMHints = getWMHints(); xWMHints.set_flags(xWMHints.get_flags() | 0x40L); xWMHints.set_window_group(l); XlibWrapper.XSetWMHints(XToolkit.getDisplay(), getWindow(), xWMHints.pData); } finally { XToolkit.awtUnlock(); }  }  }  if (window2 != null || isSimpleWindow()) { XNETProtocol xNETProtocol = XWM.getWM().getNETProtocol(); if (xNETProtocol != null && xNETProtocol.active()) { XToolkit.awtLock(); try { XAtomList xAtomList = getNETWMState(); xAtomList.add(xNETProtocol.XA_NET_WM_STATE_SKIP_TASKBAR); setNETWMState(xAtomList); } finally { XToolkit.awtUnlock(); }  }  }  if (((Window)this.target).getWarningString() != null) if (!AWTAccessor.getWindowAccessor().isTrayIconWindow((Window)this.target)) this.warningWindow = new XWarningWindow((Window)this.target, getWindow(), this);   setSaveUnder(true); updateIconImages(); updateShape(); updateOpacity(); } public void updateIconImages() { Window window = (Window)this.target; List<Image> list = window.getIconImages(); XWindowPeer xWindowPeer = getOwnerPeer(); this.winAttr.icons = new ArrayList<>(); if (list.size() != 0) { this.winAttr.iconsInherited = false; for (Image image : list) { IconInfo iconInfo; if (image == null) { if (log.isLoggable(PlatformLogger.Level.FINEST)) log.finest("XWindowPeer.updateIconImages: Skipping the image passed into Java because it's null.");  continue; }  try { iconInfo = new IconInfo(image); } catch (Exception exception) { if (log.isLoggable(PlatformLogger.Level.FINEST)) log.finest("XWindowPeer.updateIconImages: Perhaps the image passed into Java is broken. Skipping this icon.");  continue; }  if (iconInfo.isValid()) this.winAttr.icons.add(iconInfo);  }  }  this.winAttr.icons = normalizeIconImages(this.winAttr.icons); if (this.winAttr.icons.size() == 0) if (xWindowPeer != null) { this.winAttr.iconsInherited = true; this.winAttr.icons = xWindowPeer.getIconInfo(); } else { this.winAttr.iconsInherited = false; this.winAttr.icons = getDefaultIconInfo(); }   recursivelySetIcon(this.winAttr.icons); } static List<IconInfo> normalizeIconImages(List<IconInfo> paramList) { ArrayList<IconInfo> arrayList = new ArrayList(); int i = 0; boolean bool = false; for (IconInfo iconInfo : paramList) { int j = iconInfo.getWidth(); int k = iconInfo.getHeight(); int m = iconInfo.getRawLength(); if (j > 128 || k > 128) { if (bool) continue;  int n = j; int i1 = k; while (n > 128 || i1 > 128) { n /= 2; i1 /= 2; }  iconInfo.setScaledSize(n, i1); m = iconInfo.getRawLength(); }  if (i + m <= 65535) { i += m; arrayList.add(iconInfo); if (j > 128 || k > 128) bool = true;  }  }  if (iconLog.isLoggable(PlatformLogger.Level.FINEST)) iconLog.finest(">>> Length_ of buffer of icons data: " + i + ", maximum length: " + Character.MAX_VALUE);  return arrayList; } static void dumpIcons(List<IconInfo> paramList) { if (iconLog.isLoggable(PlatformLogger.Level.FINEST)) { iconLog.finest(">>> Sizes of icon images:"); for (Iterator<IconInfo> iterator = paramList.iterator(); iterator.hasNext();) { iconLog.finest("    {0}", new Object[] { iterator.next() }); }  }  } public void recursivelySetIcon(List<IconInfo> paramList) { dumpIcons(this.winAttr.icons); setIconHints(paramList); Window window = (Window)this.target; Window[] arrayOfWindow = window.getOwnedWindows(); int i = arrayOfWindow.length; for (byte b = 0; b < i; b++) { ComponentPeer componentPeer = arrayOfWindow[b].getPeer(); if (componentPeer != null && componentPeer instanceof XWindowPeer && ((XWindowPeer)componentPeer).winAttr.iconsInherited) { ((XWindowPeer)componentPeer).winAttr.icons = paramList; ((XWindowPeer)componentPeer).recursivelySetIcon(paramList); }  }  } List<IconInfo> getIconInfo() { return this.winAttr.icons; } void setIconHints(List<IconInfo> paramList) {} protected static synchronized List<IconInfo> getDefaultIconInfo() { if (defaultIconInfo == null) { defaultIconInfo = new ArrayList<>(); if (XlibWrapper.dataModel == 32) { defaultIconInfo.add(new IconInfo(AWTIcon32_java_icon16_png.java_icon16_png)); defaultIconInfo.add(new IconInfo(AWTIcon32_java_icon24_png.java_icon24_png)); defaultIconInfo.add(new IconInfo(AWTIcon32_java_icon32_png.java_icon32_png)); defaultIconInfo.add(new IconInfo(AWTIcon32_java_icon48_png.java_icon48_png)); } else { defaultIconInfo.add(new IconInfo(AWTIcon64_java_icon16_png.java_icon16_png)); defaultIconInfo.add(new IconInfo(AWTIcon64_java_icon24_png.java_icon24_png)); defaultIconInfo.add(new IconInfo(AWTIcon64_java_icon32_png.java_icon32_png)); defaultIconInfo.add(new IconInfo(AWTIcon64_java_icon48_png.java_icon48_png)); }  }  return defaultIconInfo; } private void updateShape() { Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)this.target); if (shape != null) applyShape(Region.getInstance(shape, (AffineTransform)null));  } private void updateOpacity() { float f = AWTAccessor.getWindowAccessor().getOpacity((Window)this.target); if (f < 1.0F) setOpacity(f);  } public void updateMinimumSize() { this.targetMinimumSize = this.target.isMinimumSizeSet() ? this.target.getMinimumSize() : null; } public Dimension getTargetMinimumSize() { return (this.targetMinimumSize == null) ? null : new Dimension(this.targetMinimumSize); } public XWindowPeer getOwnerPeer() { return this.ownerPeer; } public void setBounds(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) { XToolkit.awtLock(); try { Rectangle rectangle1 = getBounds(); super.setBounds(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5); Rectangle rectangle2 = getBounds(); XSizeHints xSizeHints = getHints(); setSizeHints(xSizeHints.get_flags() | 0x4L | 0x8L, rectangle2.x, rectangle2.y, rectangle2.width, rectangle2.height); XWM.setMotifDecor(this, false, 0, 0); boolean bool1 = !rectangle2.getSize().equals(rectangle1.getSize()) ? true : false; boolean bool2 = !rectangle2.getLocation().equals(rectangle1.getLocation()) ? true : false; if (bool2 || bool1) repositionSecurityWarning();  if (bool1) postEventToEventQueue(new ComponentEvent(getEventSource(), 101));  if (bool2) postEventToEventQueue(new ComponentEvent(getEventSource(), 100));  } finally { XToolkit.awtUnlock(); }  } void updateFocusability() { updateFocusableWindowState(); XToolkit.awtLock(); try { XWMHints xWMHints = getWMHints(); xWMHints.set_flags(xWMHints.get_flags() | 0x1L); xWMHints.set_input(false); XlibWrapper.XSetWMHints(XToolkit.getDisplay(), getWindow(), xWMHints.pData); } finally { XToolkit.awtUnlock(); }  } public Insets getInsets() { return new Insets(0, 0, 0, 0); } public void handleIconify() { postEvent(new WindowEvent((Window)this.target, 203)); } public void handleDeiconify() { postEvent(new WindowEvent((Window)this.target, 204)); } public void handleStateChange(int paramInt1, int paramInt2) { postEvent(new WindowEvent((Window)this.target, 209, paramInt1, paramInt2)); } public Insets insets() { return getInsets(); } boolean isAutoRequestFocus() { if (XToolkit.isToolkitThread()) return AWTAccessor.getWindowAccessor().isAutoRequestFocus((Window)this.target);  return ((Window)this.target).isAutoRequestFocus(); } static XWindowPeer getNativeFocusedWindowPeer() { XBaseWindow xBaseWindow = XToolkit.windowToXWindow(xGetInputFocus()); return (xBaseWindow instanceof XWindowPeer) ? (XWindowPeer)xBaseWindow : ((xBaseWindow instanceof XFocusProxyWindow) ? ((XFocusProxyWindow)xBaseWindow).getOwner() : null); } static Window getNativeFocusedWindow() { XWindowPeer xWindowPeer = getNativeFocusedWindowPeer(); return (xWindowPeer != null) ? (Window)xWindowPeer.target : null; } boolean isFocusableWindow() { if (XToolkit.isToolkitThread() || SunToolkit.isAWTLockHeldByCurrentThread()) return this.cachedFocusableWindow;  return ((Window)this.target).isFocusableWindow(); } boolean isFocusedWindowModalBlocker() { return false; } long getFocusTargetWindow() { return getContentWindow(); } XWindowPeer(Window paramWindow) { super(new XCreateWindowParams(new Object[] { "target", paramWindow, "parent window", Long.valueOf(0L) })); this.dropTargetCount = 0; this.pressTarget = this; }
/*      */   boolean isNativelyNonFocusableWindow() { if (XToolkit.isToolkitThread() || SunToolkit.isAWTLockHeldByCurrentThread()) return (isSimpleWindow() || !this.cachedFocusableWindow);  return (isSimpleWindow() || !((Window)this.target).isFocusableWindow()); } public void handleWindowFocusIn_Dispatch() { if (EventQueue.isDispatchThread()) { XKeyboardFocusManagerPeer.getInstance().setCurrentFocusedWindow((Window)this.target); WindowEvent windowEvent = new WindowEvent((Window)this.target, 207); SunToolkit.setSystemGenerated(windowEvent); this.target.dispatchEvent(windowEvent); }  } public void handleWindowFocusInSync(long paramLong) { WindowEvent windowEvent = new WindowEvent((Window)this.target, 207); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusedWindow((Window)this.target); sendEvent(windowEvent); } public void handleWindowFocusIn(long paramLong) { WindowEvent windowEvent = new WindowEvent((Window)this.target, 207); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusedWindow((Window)this.target); postEvent(wrapInSequenced(windowEvent)); } public void handleWindowFocusOut(Window paramWindow, long paramLong) { WindowEvent windowEvent = new WindowEvent((Window)this.target, 208, paramWindow); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusedWindow(null); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusOwner(null); postEvent(wrapInSequenced(windowEvent)); } public void handleWindowFocusOutSync(Window paramWindow, long paramLong) { WindowEvent windowEvent = new WindowEvent((Window)this.target, 208, paramWindow); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusedWindow(null); XKeyboardFocusManagerPeer.getInstance().setCurrentFocusOwner(null); sendEvent(windowEvent); } public void checkIfOnNewScreen(Rectangle paramRectangle) { if (!XToolkit.localEnv.runningXinerama()) return;  if (log.isLoggable(PlatformLogger.Level.FINEST)) log.finest("XWindowPeer: Check if we've been moved to a new screen since we're running in Xinerama mode");  int i = paramRectangle.width * paramRectangle.height; int j = 0; int k = ((X11GraphicsDevice)getGraphicsConfiguration().getDevice()).getScreen(); byte b = 0; GraphicsDevice[] arrayOfGraphicsDevice = XToolkit.localEnv.getScreenDevices(); GraphicsConfiguration graphicsConfiguration = null; XToolkit.awtUnlock(); try { for (byte b1 = 0; b1 < arrayOfGraphicsDevice.length; b1++) { Rectangle rectangle = arrayOfGraphicsDevice[b1].getDefaultConfiguration().getBounds(); if (paramRectangle.intersects(rectangle)) { int i1 = Math.min(paramRectangle.x + paramRectangle.width, rectangle.x + rectangle.width) - Math.max(paramRectangle.x, rectangle.x); int n = Math.min(paramRectangle.y + paramRectangle.height, rectangle.y + rectangle.height) - Math.max(paramRectangle.y, rectangle.y); int m = i1 * n; if (m == i) { b = b1; graphicsConfiguration = arrayOfGraphicsDevice[b1].getDefaultConfiguration(); break; }  if (m > j) { j = m; b = b1; graphicsConfiguration = arrayOfGraphicsDevice[b1].getDefaultConfiguration(); }  }  }  } finally { XToolkit.awtLock(); }  if (b != k) { if (log.isLoggable(PlatformLogger.Level.FINEST)) log.finest("XWindowPeer: Moved to a new screen");  executeDisplayChangedOnEDT(graphicsConfiguration); }  } private void executeDisplayChangedOnEDT(final GraphicsConfiguration gc) { Runnable runnable = new Runnable() {
/*      */         public void run() { AWTAccessor.getComponentAccessor().setGraphicsConfiguration(XWindowPeer.this.target, gc); }
/* 2205 */       }; SunToolkit.executeOnEventHandlerThread(this.target, runnable); } public void displayChanged() { executeDisplayChangedOnEDT(getGraphicsConfiguration()); } public void paletteChanged() {} private Point queryXLocation() { return XlibUtil.translateCoordinates(getContentWindow(), XlibWrapper.RootWindow(XToolkit.getDisplay(), getScreenNumber()), new Point(0, 0)); } protected Point getNewLocation(XConfigureEvent paramXConfigureEvent, int paramInt1, int paramInt2) { Rectangle rectangle = AWTAccessor.getComponentAccessor().getBounds(this.target); int i = XWM.getWMID(); Point point = rectangle.getLocation(); if (paramXConfigureEvent.get_send_event() || i == 2 || XWM.isNonReparentingWM()) { point = new Point(paramXConfigureEvent.get_x() - paramInt1, paramXConfigureEvent.get_y() - paramInt2); } else { Point point1; switch (i) { case 5: case 6: case 9: case 11: case 15: point1 = queryXLocation(); if (log.isLoggable(PlatformLogger.Level.FINE)) log.fine("New X location: {0}", new Object[] { point1 });  if (point1 != null) point = point1;  break; }  }  return point; } public void handleConfigureNotifyEvent(XEvent paramXEvent) { XConfigureEvent xConfigureEvent = paramXEvent.get_xconfigure(); Point point = getNewLocation(xConfigureEvent, 0, 0); xConfigureEvent.set_x(point.x); xConfigureEvent.set_y(point.y); checkIfOnNewScreen(new Rectangle(xConfigureEvent.get_x(), xConfigureEvent.get_y(), xConfigureEvent.get_width(), xConfigureEvent.get_height())); super.handleConfigureNotifyEvent(paramXEvent); repositionSecurityWarning(); } final void requestXFocus(long paramLong) { requestXFocus(paramLong, true); } final void requestXFocus() { requestXFocus(0L, false); } protected void requestXFocus(long paramLong, boolean paramBoolean) { if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("Requesting window focus");  requestWindowFocus(paramLong, paramBoolean); } public final boolean focusAllowedFor() { if (isNativelyNonFocusableWindow()) return false;  if (isModalBlocked()) return false;  return true; } public void handleFocusEvent(XEvent paramXEvent) { XFocusChangeEvent xFocusChangeEvent = paramXEvent.get_xfocus(); if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("{0}", new Object[] { xFocusChangeEvent });  if (isEventDisabled(paramXEvent)) return;  if (paramXEvent.get_type() == 9) { if (focusAllowedFor() && (xFocusChangeEvent.get_mode() == 0 || xFocusChangeEvent.get_mode() == 3)) handleWindowFocusIn(xFocusChangeEvent.get_serial());  } else if (xFocusChangeEvent.get_mode() == 0 || xFocusChangeEvent.get_mode() == 3) { if (!isNativelyNonFocusableWindow()) { XWindowPeer xWindowPeer = getNativeFocusedWindowPeer(); Object object = (xWindowPeer != null) ? xWindowPeer.getTarget() : null; Window window = null; if (object instanceof Window) window = (Window)object;  if (xWindowPeer != null && xWindowPeer.isNativelyNonFocusableWindow()) return;  if (this == xWindowPeer) { window = null; } else if (xWindowPeer instanceof XDecoratedPeer && ((XDecoratedPeer)xWindowPeer).actualFocusedWindow != null) { xWindowPeer = ((XDecoratedPeer)xWindowPeer).actualFocusedWindow; object = xWindowPeer.getTarget(); if (object instanceof Window && xWindowPeer.isVisible() && xWindowPeer.isNativelyNonFocusableWindow()) window = (Window)object;  }  handleWindowFocusOut(window, xFocusChangeEvent.get_serial()); }  }  } void setSaveUnder(boolean paramBoolean) {} public void toFront() { if (isOverrideRedirect() && this.mustControlStackPosition) { this.mustControlStackPosition = false; removeRootPropertyEventDispatcher(); }  if (isVisible()) { super.toFront(); if (isFocusableWindow() && isAutoRequestFocus() && !isModalBlocked() && !isWithdrawn()) requestInitialFocus();  } else { setVisible(true); }  } public void toBack() { XToolkit.awtLock(); try { if (!isOverrideRedirect()) { XlibWrapper.XLowerWindow(XToolkit.getDisplay(), getWindow()); } else { lowerOverrideRedirect(); }  } finally { XToolkit.awtUnlock(); }  } private void lowerOverrideRedirect() { HashSet<Long> hashSet = new HashSet(); long l1 = 0L, l2 = 0L; for (XWindowPeer xWindowPeer : windows) { l1 = getToplevelWindow(xWindowPeer.getWindow()); if (xWindowPeer.equals(this)) l2 = l1;  if (l1 > 0L) hashSet.add(Long.valueOf(l1));  }  long l3 = -1L, l4 = -1L; byte b1 = -1, b2 = -1, b3 = -1; byte b = 0; XQueryTree xQueryTree = new XQueryTree(XToolkit.getDefaultRootWindow()); try { if (xQueryTree.execute() > 0) { int i = xQueryTree.get_nchildren(); long l5 = xQueryTree.get_children(); for (b = 0; b < i; b++) { long l6 = Native.getWindow(l5, b); if (l6 == l2) { b1 = b; } else if (isDesktopWindow(l6)) { b2 = b; l3 = l6; } else if (b3 < 0 && hashSet.contains(Long.valueOf(l6)) && l6 != l2) { b3 = b; l4 = l6; }  }  }  if ((b1 < b3 || b3 < 0) && b2 < b1) return;  long l = Native.allocateLongArray(2); Native.putLong(l, 0, l4); Native.putLong(l, 1, l2); XlibWrapper.XRestackWindows(XToolkit.getDisplay(), l, 2); XlibWrapper.unsafe.freeMemory(l); if (!this.mustControlStackPosition) { this.mustControlStackPosition = true; addRootPropertyEventDispatcher(); }  } finally { xQueryTree.dispose(); }  } private long getToplevelWindow(long paramLong) { long l2, l3, l1 = paramLong; do { l2 = l1; XQueryTree xQueryTree = new XQueryTree(l1); try { if (xQueryTree.execute() == 0) return 0L;  l3 = xQueryTree.get_root(); l1 = xQueryTree.get_parent(); } finally { xQueryTree.dispose(); }  } while (l1 != l3); return l2; } private static boolean isDesktopWindow(long paramLong) { return XWM.getWM().isDesktopWindow(paramLong); } private void updateAlwaysOnTop() { if (log.isLoggable(PlatformLogger.Level.FINE)) log.fine("Promoting always-on-top state {0}", new Object[] { Boolean.valueOf(this.alwaysOnTop) });  XWM.getWM().setLayer(this, this.alwaysOnTop ? 1 : 0); } public void updateAlwaysOnTopState() { this.alwaysOnTop = ((Window)this.target).isAlwaysOnTop(); updateAlwaysOnTop(); } boolean isLocationByPlatform() { return this.locationByPlatform; } private void promoteDefaultPosition() { this.locationByPlatform = ((Window)this.target).isLocationByPlatform(); if (this.locationByPlatform) { XToolkit.awtLock(); try { Rectangle rectangle = getBounds(); XSizeHints xSizeHints = getHints(); setSizeHints(xSizeHints.get_flags() & 0xFFFFFFFFFFFFFFFAL, rectangle.x, rectangle.y, rectangle.width, rectangle.height); } finally { XToolkit.awtUnlock(); }  }  } public void setVisible(boolean paramBoolean) { if (!isVisible() && paramBoolean) { this.isBeforeFirstMapNotify = true; this.winAttr.initialFocus = isAutoRequestFocus(); if (!this.winAttr.initialFocus) suppressWmTakeFocus(true);  }  updateFocusability(); promoteDefaultPosition(); if (!paramBoolean && this.warningWindow != null) this.warningWindow.setSecurityWarningVisible(false, false);  super.setVisible(paramBoolean); if (!paramBoolean && !isWithdrawn()) { XToolkit.awtLock(); try { XUnmapEvent xUnmapEvent = new XUnmapEvent(); xUnmapEvent.set_window(this.window); xUnmapEvent.set_event(XToolkit.getDefaultRootWindow()); xUnmapEvent.set_type(18); xUnmapEvent.set_from_configure(false); XlibWrapper.XSendEvent(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(), false, 1572864L, xUnmapEvent.pData); xUnmapEvent.dispose(); } finally { XToolkit.awtUnlock(); }  }  if (isOverrideRedirect() && paramBoolean) updateChildrenSizes();  repositionSecurityWarning(); } public void handleButtonPressRelease(XEvent paramXEvent) { XButtonEvent xButtonEvent = paramXEvent.get_xbutton();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 2212 */     if (xButtonEvent.get_button() > 20) {
/*      */       return;
/*      */     }
/* 2215 */     if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {
/* 2216 */       grabLog.fine("{0}, when grabbed {1}, contains {2} ({3}, {4}, {5}x{6})", new Object[] { xButtonEvent, 
/* 2217 */             Boolean.valueOf(isGrabbed()), Boolean.valueOf(containsGlobal(xButtonEvent.get_x_root(), xButtonEvent.get_y_root())), Integer.valueOf(getAbsoluteX()), Integer.valueOf(getAbsoluteY()), Integer.valueOf(getWidth()), Integer.valueOf(getHeight()) });
/*      */     }
/* 2219 */     if (isGrabbed()) {
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 2224 */       XBaseWindow xBaseWindow = XToolkit.windowToXWindow(xButtonEvent.get_window());
/*      */       try {
/* 2226 */         if (grabLog.isLoggable(PlatformLogger.Level.FINER)) {
/* 2227 */           grabLog.finer("  -  Grab event target {0} (press target {1})", new Object[] { xBaseWindow, this.pressTarget });
/*      */         }
/* 2229 */         if (xButtonEvent.get_type() == 4 && xButtonEvent
/* 2230 */           .get_button() == XConstants.buttons[0]) {
/*      */ 
/*      */           
/* 2233 */           this.pressTarget = xBaseWindow;
/* 2234 */         } else if (xButtonEvent.get_type() == 5 && xButtonEvent
/* 2235 */           .get_button() == XConstants.buttons[0] && this.pressTarget != xBaseWindow) {
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */           
/* 2241 */           xBaseWindow = this.pressTarget.isVisible() ? this.pressTarget : this;
/* 2242 */           xButtonEvent.set_window(xBaseWindow.getWindow());
/* 2243 */           Point point = xBaseWindow.toLocal(xButtonEvent.get_x_root(), xButtonEvent.get_y_root());
/* 2244 */           xButtonEvent.set_x(point.x);
/* 2245 */           xButtonEvent.set_y(point.y);
/* 2246 */           this.pressTarget = this;
/*      */         } 
/* 2248 */         if (xBaseWindow != null && xBaseWindow != getContentXWindow() && xBaseWindow != this) {
/* 2249 */           xBaseWindow.dispatchEvent(paramXEvent);
/*      */           return;
/*      */         } 
/*      */       } finally {
/* 2253 */         if (xBaseWindow != null) {
/*      */ 
/*      */ 
/*      */           
/* 2257 */           if ((xBaseWindow == this || xBaseWindow == getContentXWindow()) && !containsGlobal(xButtonEvent.get_x_root(), xButtonEvent.get_y_root()))
/*      */           {
/*      */ 
/*      */             
/* 2261 */             if (xButtonEvent.get_type() == 4) {
/* 2262 */               if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {
/* 2263 */                 grabLog.fine("Generating UngrabEvent on {0} because not inside of shell", new Object[] { this });
/*      */               }
/* 2265 */               postEventToEventQueue(new UngrabEvent(getEventSource()));
/*      */               
/*      */               return;
/*      */             } 
/*      */           }
/* 2270 */           XWindowPeer xWindowPeer = xBaseWindow.getToplevelXWindow();
/* 2271 */           if (xWindowPeer != null) {
/* 2272 */             Window window = (Window)xWindowPeer.target;
/* 2273 */             while (window != null && xWindowPeer != this && !(xWindowPeer instanceof XDialogPeer)) {
/* 2274 */               window = (Window)AWTAccessor.getComponentAccessor().getParent(window);
/* 2275 */               if (window != null) {
/* 2276 */                 xWindowPeer = AWTAccessor.getComponentAccessor().<XWindowPeer>getPeer(window);
/*      */               }
/*      */             } 
/* 2279 */             if (window == null || (window != this.target && window instanceof Dialog)) {
/*      */ 
/*      */ 
/*      */               
/* 2283 */               if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {
/* 2284 */                 grabLog.fine("Generating UngrabEvent on {0} because hierarchy ended", new Object[] { this });
/*      */               }
/* 2286 */               postEventToEventQueue(new UngrabEvent(getEventSource()));
/*      */             } 
/*      */           } else {
/*      */             
/* 2290 */             if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {
/* 2291 */               grabLog.fine("Generating UngrabEvent on {0} because toplevel is null", new Object[] { this });
/*      */             }
/* 2293 */             postEventToEventQueue(new UngrabEvent(getEventSource()));
/*      */             
/*      */             return;
/*      */           } 
/*      */         } else {
/* 2298 */           if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {
/* 2299 */             grabLog.fine("Generating UngrabEvent on because target is null {0}", new Object[] { this });
/*      */           }
/* 2301 */           postEventToEventQueue(new UngrabEvent(getEventSource()));
/*      */           return;
/*      */         } 
/*      */       } 
/*      */     } 
/* 2306 */     super.handleButtonPressRelease(paramXEvent); } protected void suppressWmTakeFocus(boolean paramBoolean) {} final boolean isSimpleWindow() { return (!(this.target instanceof java.awt.Frame) && !(this.target instanceof Dialog)); } boolean hasWarningWindow() { return (((Window)this.target).getWarningString() != null); } int getMenuBarHeight() { return 0; } void updateChildrenSizes() {} public void repositionSecurityWarning() { if (this.warningWindow != null) { AWTAccessor.ComponentAccessor componentAccessor = AWTAccessor.getComponentAccessor(); int i = componentAccessor.getX(this.target); int j = componentAccessor.getY(this.target); int k = componentAccessor.getWidth(this.target); int m = componentAccessor.getHeight(this.target); this.warningWindow.reposition(i, j, k, m); }  } protected void setMouseAbove(boolean paramBoolean) { super.setMouseAbove(paramBoolean); updateSecurityWarningVisibility(); } public void setFullScreenExclusiveModeState(boolean paramBoolean) { super.setFullScreenExclusiveModeState(paramBoolean); updateSecurityWarningVisibility(); } public void updateSecurityWarningVisibility() { if (this.warningWindow == null) return;  if (!isVisible()) return;  boolean bool = false; if (!isFullScreenExclusiveMode()) { int i = getWMState(); if (isVisible() && (i == 1 || isSimpleWindow())) { if (XKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow() == getTarget()) bool = true;  if (isMouseAbove() || this.warningWindow.isMouseAbove()) bool = true;  }  }  this.warningWindow.setSecurityWarningVisible(bool, true); } boolean isOverrideRedirect() { return (XWM.getWMID() == 4 || XWM.getWMID() == 12 || Window.Type.POPUP.equals(getWindowType())); } final boolean isOLWMDecorBug() { return (XWM.getWMID() == 4 && !this.winAttr.nativeDecor); } public void dispose() { if (isGrabbed()) { if (grabLog.isLoggable(PlatformLogger.Level.FINE)) grabLog.fine("Generating UngrabEvent on {0} because of the window disposal", new Object[] { this });  postEventToEventQueue(new UngrabEvent(getEventSource())); }  SunToolkit.awtLock(); try { windows.remove(this); } finally { SunToolkit.awtUnlock(); }  if (this.warningWindow != null) this.warningWindow.destroy();  removeRootPropertyEventDispatcher(); this.mustControlStackPosition = false; super.dispose(); if (isSimpleWindow() && this.target == XKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow()) { Window window = getDecoratedOwner((Window)this.target); ((XWindowPeer)AWTAccessor.getComponentAccessor().<XWindowPeer>getPeer(window)).requestWindowFocus(); }  } boolean isResizable() { return this.winAttr.isResizable; } public void handleVisibilityEvent(XEvent paramXEvent) { super.handleVisibilityEvent(paramXEvent); XVisibilityEvent xVisibilityEvent = paramXEvent.get_xvisibility(); this.winAttr.visibilityState = xVisibilityEvent.get_state(); repositionSecurityWarning(); } void handleRootPropertyNotify(XEvent paramXEvent) { XPropertyEvent xPropertyEvent = paramXEvent.get_xproperty(); if (this.mustControlStackPosition && xPropertyEvent.get_atom() == XAtom.get("_NET_CLIENT_LIST_STACKING").getAtom()) if (isOverrideRedirect()) toBack();   } private void removeStartupNotification() { byte[] arrayOfByte; if (isStartupNotificationRemoved.getAndSet(true)) return;  String str = AccessController.<String>doPrivileged(new PrivilegedAction<String>() { public String run() { return XToolkit.getEnv("DESKTOP_STARTUP_ID"); } }
/*      */       ); if (str == null) return;  StringBuilder stringBuilder = new StringBuilder("remove: ID="); stringBuilder.append('"'); for (byte b = 0; b < str.length(); b++) { if (str.charAt(b) == '"' || str.charAt(b) == '\\') stringBuilder.append('\\');  stringBuilder.append(str.charAt(b)); }  stringBuilder.append('"'); stringBuilder.append(false); try { arrayOfByte = stringBuilder.toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException unsupportedEncodingException) { return; }  XClientMessageEvent xClientMessageEvent = null; XToolkit.awtLock(); try { XAtom xAtom1 = XAtom.get("_NET_STARTUP_INFO_BEGIN"); XAtom xAtom2 = XAtom.get("_NET_STARTUP_INFO"); xClientMessageEvent = new XClientMessageEvent(); xClientMessageEvent.set_type(33); xClientMessageEvent.set_window(getWindow()); xClientMessageEvent.set_message_type(xAtom1.getAtom()); xClientMessageEvent.set_format(8); for (byte b1 = 0; b1 < arrayOfByte.length; b1 += 20) { int i = Math.min(arrayOfByte.length - b1, 20); byte b2 = 0; for (; b2 < i; b2++) XlibWrapper.unsafe.putByte(xClientMessageEvent.get_data() + b2, arrayOfByte[b1 + b2]);  for (; b2 < 20; b2++) XlibWrapper.unsafe.putByte(xClientMessageEvent.get_data() + b2, (byte)0);  XlibWrapper.XSendEvent(XToolkit.getDisplay(), XlibWrapper.RootWindow(XToolkit.getDisplay(), getScreenNumber()), false, 4194304L, xClientMessageEvent.pData); xClientMessageEvent.set_message_type(xAtom2.getAtom()); }  } finally { XToolkit.awtUnlock(); if (xClientMessageEvent != null) xClientMessageEvent.dispose();  }  } public void handleMapNotifyEvent(XEvent paramXEvent) { removeStartupNotification(); this.isUnhiding |= isWMStateNetHidden(); super.handleMapNotifyEvent(paramXEvent); if (!this.winAttr.initialFocus) { suppressWmTakeFocus(false); XToolkit.awtLock(); try { XlibWrapper.XRaiseWindow(XToolkit.getDisplay(), getWindow()); } finally { XToolkit.awtUnlock(); }  }  if (shouldFocusOnMapNotify()) { focusLog.fine("Automatically request focus on window"); requestInitialFocus(); }  this.isUnhiding = false; this.isBeforeFirstMapNotify = false; updateAlwaysOnTop(); synchronized (getStateLock()) { if (!this.isMapped) this.isMapped = true;  }  } public void handleUnmapNotifyEvent(XEvent paramXEvent) { super.handleUnmapNotifyEvent(paramXEvent); this.isUnhiding |= isWMStateNetHidden(); synchronized (getStateLock()) { if (this.isMapped) this.isMapped = false;  }  } private boolean shouldFocusOnMapNotify() { boolean bool = false; if (this.isBeforeFirstMapNotify) { bool = (this.winAttr.initialFocus || isFocusedWindowModalBlocker()); } else { bool = this.isUnhiding; }  bool = (bool && isFocusableWindow() && !isModalBlocked()); return bool; } protected boolean isWMStateNetHidden() { XNETProtocol xNETProtocol = XWM.getWM().getNETProtocol(); return (xNETProtocol != null && xNETProtocol.isWMStateNetHidden(this)); } protected void requestInitialFocus() { requestXFocus(); } public void addToplevelStateListener(ToplevelStateListener paramToplevelStateListener) { this.toplevelStateListeners.add(paramToplevelStateListener); } public void removeToplevelStateListener(ToplevelStateListener paramToplevelStateListener) { this.toplevelStateListeners.remove(paramToplevelStateListener); } protected void stateChanged(long paramLong, int paramInt1, int paramInt2) { updateTransientFor(); for (ToplevelStateListener toplevelStateListener : this.toplevelStateListeners) toplevelStateListener.stateChangedICCCM(paramInt1, paramInt2);  updateSecurityWarningVisibility(); } boolean isWithdrawn() { return (getWMState() == 0); }
/*      */   boolean hasDecorations(int paramInt) { if (!this.winAttr.nativeDecor) return false;  int i = this.winAttr.decorations; boolean bool = ((i & paramInt) == paramInt) ? true : false; if ((i & XWindowAttributesData.AWT_DECOR_ALL) != 0) return !bool;  return bool; }
/*      */   void setReparented(boolean paramBoolean) { super.setReparented(paramBoolean); XToolkit.awtLock(); try { if (isReparented() && this.delayedModalBlocking) { addToTransientFors(AWTAccessor.getComponentAccessor().<XDialogPeer>getPeer(this.modalBlocker)); this.delayedModalBlocking = false; }  } finally { XToolkit.awtUnlock(); }  }
/*      */   static Vector<XWindowPeer> collectJavaToplevels() { Vector<XWindowPeer> vector = new Vector(); Vector<Long> vector1 = new Vector(); X11GraphicsEnvironment x11GraphicsEnvironment = (X11GraphicsEnvironment)GraphicsEnvironment.getLocalGraphicsEnvironment(); GraphicsDevice[] arrayOfGraphicsDevice = x11GraphicsEnvironment.getScreenDevices(); if (!x11GraphicsEnvironment.runningXinerama() && arrayOfGraphicsDevice.length > 1) { for (GraphicsDevice graphicsDevice : arrayOfGraphicsDevice) { int j = ((X11GraphicsDevice)graphicsDevice).getScreen(); long l = XlibWrapper.RootWindow(XToolkit.getDisplay(), j); vector1.add(Long.valueOf(l)); }  } else { vector1.add(Long.valueOf(XToolkit.getDefaultRootWindow())); }  int i = windows.size(); while (vector1.size() > 0 && vector.size() < i) { long l = ((Long)vector1.remove(0)).longValue(); XQueryTree xQueryTree = new XQueryTree(l); try { if (xQueryTree.execute() != 0) { int j = xQueryTree.get_nchildren(); long l1 = xQueryTree.get_children(); for (byte b = 0; b < j; b++) { long l2 = Native.getWindow(l1, b); XBaseWindow xBaseWindow = XToolkit.windowToXWindow(l2); if (xBaseWindow == null || xBaseWindow instanceof XWindowPeer) { vector1.add(Long.valueOf(l2)); if (xBaseWindow instanceof XWindowPeer) { XWindowPeer xWindowPeer1 = (XWindowPeer)xBaseWindow; vector.add(xWindowPeer1); byte b1 = 0; XWindowPeer xWindowPeer2 = vector.get(b1); while (xWindowPeer2 != xWindowPeer1) { XWindowPeer xWindowPeer = xWindowPeer2.getOwnerPeer(); if (xWindowPeer == xWindowPeer1) { vector.remove(b1); vector.add(xWindowPeer2); } else { b1++; }  xWindowPeer2 = vector.get(b1); }  }  }  }  }  } finally { xQueryTree.dispose(); }  }  return vector; }
/*      */   public void setModalBlocked(Dialog paramDialog, boolean paramBoolean) { setModalBlocked(paramDialog, paramBoolean, (Vector<XWindowPeer>)null); }
/* 2312 */   public void print(Graphics paramGraphics) { Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)this.target);
/* 2313 */     if (shape != null) {
/* 2314 */       paramGraphics.setClip(shape);
/*      */     }
/* 2316 */     super.print(paramGraphics); } public void setModalBlocked(Dialog paramDialog, boolean paramBoolean, Vector<XWindowPeer> paramVector) { XToolkit.awtLock(); try { synchronized (getStateLock()) { XDialogPeer xDialogPeer = AWTAccessor.getComponentAccessor().<XDialogPeer>getPeer(paramDialog); if (paramBoolean) { if (log.isLoggable(PlatformLogger.Level.FINE)) log.fine("{0} is blocked by {1}", new Object[] { this, xDialogPeer });  this.modalBlocker = paramDialog; if (isReparented() || XWM.isNonReparentingWM()) { addToTransientFors(xDialogPeer, paramVector); } else { this.delayedModalBlocking = true; }  } else { if (paramDialog != this.modalBlocker) throw new IllegalStateException("Trying to unblock window blocked by another dialog");  this.modalBlocker = null; if (isReparented() || XWM.isNonReparentingWM()) { removeFromTransientFors(); } else { this.delayedModalBlocking = false; }  }  updateTransientFor(); }  } finally { XToolkit.awtUnlock(); }  } static void setToplevelTransientFor(XWindowPeer paramXWindowPeer1, XWindowPeer paramXWindowPeer2, boolean paramBoolean1, boolean paramBoolean2) { if (paramXWindowPeer1 == null || paramXWindowPeer2 == null) return;  if (paramBoolean1) { paramXWindowPeer1.prevTransientFor = paramXWindowPeer2; paramXWindowPeer2.nextTransientFor = paramXWindowPeer1; }  if (paramXWindowPeer1.curRealTransientFor == paramXWindowPeer2) return;  if (!paramBoolean2 && paramXWindowPeer1.getWMState() != paramXWindowPeer2.getWMState()) return;  if (paramXWindowPeer1.getScreenNumber() != paramXWindowPeer2.getScreenNumber()) return;  long l1 = paramXWindowPeer1.getWindow(); while (!XlibUtil.isToplevelWindow(l1) && !XlibUtil.isXAWTToplevelWindow(l1)) l1 = XlibUtil.getParentWindow(l1);  long l2 = paramXWindowPeer2.getWindow(); while (!XlibUtil.isToplevelWindow(l2) && !XlibUtil.isXAWTToplevelWindow(l2)) l2 = XlibUtil.getParentWindow(l2);  XWindowPeer xWindowPeer = paramXWindowPeer2; if (xWindowPeer instanceof XLightweightFramePeer) { XLightweightFramePeer xLightweightFramePeer = (XLightweightFramePeer)xWindowPeer; long l = xLightweightFramePeer.getOverriddenWindowHandle(); if (l != 0L) l2 = l;  }  XlibWrapper.XSetTransientFor(XToolkit.getDisplay(), l1, l2); paramXWindowPeer1.curRealTransientFor = paramXWindowPeer2; } void updateTransientFor() { int i = getWMState(); XWindowPeer xWindowPeer1 = this.prevTransientFor; while (xWindowPeer1 != null && (xWindowPeer1.getWMState() != i || xWindowPeer1.getScreenNumber() != getScreenNumber())) xWindowPeer1 = xWindowPeer1.prevTransientFor;  if (xWindowPeer1 != null) { setToplevelTransientFor(this, xWindowPeer1, false, false); } else { restoreTransientFor(this); }  XWindowPeer xWindowPeer2 = this.nextTransientFor; while (xWindowPeer2 != null && (xWindowPeer2.getWMState() != i || xWindowPeer2.getScreenNumber() != getScreenNumber())) xWindowPeer2 = xWindowPeer2.nextTransientFor;  if (xWindowPeer2 != null) setToplevelTransientFor(xWindowPeer2, this, false, false);  } private static void removeTransientForHint(XWindowPeer paramXWindowPeer) { XAtom xAtom = XAtom.get(68L); long l = paramXWindowPeer.getWindow(); while (!XlibUtil.isToplevelWindow(l) && !XlibUtil.isXAWTToplevelWindow(l)) l = XlibUtil.getParentWindow(l);  XlibWrapper.XDeleteProperty(XToolkit.getDisplay(), l, xAtom.getAtom()); paramXWindowPeer.curRealTransientFor = null; } private void addToTransientFors(XDialogPeer paramXDialogPeer) { addToTransientFors(paramXDialogPeer, (Vector<XWindowPeer>)null); } private void addToTransientFors(XDialogPeer paramXDialogPeer, Vector<XWindowPeer> paramVector) { XWindowPeer xWindowPeer1 = paramXDialogPeer; while (xWindowPeer1.prevTransientFor != null) xWindowPeer1 = xWindowPeer1.prevTransientFor;  XWindowPeer xWindowPeer2 = this; while (xWindowPeer2.prevTransientFor != null) xWindowPeer2 = xWindowPeer2.prevTransientFor;  if (xWindowPeer1 == paramXDialogPeer) { setToplevelTransientFor(paramXDialogPeer, this, true, false); } else { if (paramVector == null) paramVector = collectJavaToplevels();  XWindowPeer xWindowPeer = null; for (XWindowPeer xWindowPeer3 : paramVector) { XWindowPeer xWindowPeer4 = xWindowPeer; if (xWindowPeer3 == xWindowPeer2) { if (xWindowPeer2 == this) { if (xWindowPeer4 != null) setToplevelTransientFor(this, xWindowPeer4, true, false);  setToplevelTransientFor(xWindowPeer1, this, true, false); break; }  xWindowPeer = xWindowPeer2; xWindowPeer2 = xWindowPeer2.nextTransientFor; } else if (xWindowPeer3 == xWindowPeer1) { xWindowPeer = xWindowPeer1; xWindowPeer1 = xWindowPeer1.nextTransientFor; } else { continue; }  if (xWindowPeer4 == null) { xWindowPeer.prevTransientFor = null; } else { setToplevelTransientFor(xWindowPeer, xWindowPeer4, true, false); xWindowPeer.updateTransientFor(); }  if (xWindowPeer1 == paramXDialogPeer) { setToplevelTransientFor(xWindowPeer2, xWindowPeer, true, false); setToplevelTransientFor(xWindowPeer1, this, true, false); break; }  }  }  XToolkit.XSync(); } static void restoreTransientFor(XWindowPeer paramXWindowPeer) { XWindowPeer xWindowPeer = paramXWindowPeer.getOwnerPeer(); if (xWindowPeer != null) { setToplevelTransientFor(paramXWindowPeer, xWindowPeer, false, true); } else { removeTransientForHint(paramXWindowPeer); }  } private void removeFromTransientFors() { XWindowPeer xWindowPeer1 = this; XWindowPeer xWindowPeer2 = this.nextTransientFor; HashSet<XWindowPeer> hashSet = new HashSet(); hashSet.add(this); XWindowPeer xWindowPeer3 = this.prevTransientFor; while (xWindowPeer3 != null) { XWindowPeer xWindowPeer = AWTAccessor.getComponentAccessor().<XWindowPeer>getPeer(xWindowPeer3.modalBlocker); if (hashSet.contains(xWindowPeer)) { setToplevelTransientFor(xWindowPeer1, xWindowPeer3, true, false); xWindowPeer1 = xWindowPeer3; hashSet.add(xWindowPeer3); } else { setToplevelTransientFor(xWindowPeer2, xWindowPeer3, true, false); xWindowPeer2 = xWindowPeer3; }  xWindowPeer3 = xWindowPeer3.prevTransientFor; }  restoreTransientFor(xWindowPeer1); xWindowPeer1.prevTransientFor = null; restoreTransientFor(xWindowPeer2); xWindowPeer2.prevTransientFor = null; this.nextTransientFor = null; XToolkit.XSync(); } boolean isModalBlocked() { return (this.modalBlocker != null); } static Window getDecoratedOwner(Window paramWindow) { while (null != paramWindow && !(paramWindow instanceof java.awt.Frame) && !(paramWindow instanceof Dialog)) paramWindow = (Window)AWTAccessor.getComponentAccessor().getParent(paramWindow);  return paramWindow; } public boolean requestWindowFocus(XWindowPeer paramXWindowPeer) { setActualFocusedWindow(paramXWindowPeer); return requestWindowFocus(); } public boolean requestWindowFocus() { return requestWindowFocus(0L, false); } public boolean requestWindowFocus(long paramLong, boolean paramBoolean) { focusLog.fine("Request for window focus"); Window window1 = getDecoratedOwner((Window)this.target); Window window2 = XKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow(); Window window3 = getDecoratedOwner(window2); if (isWMStateNetHidden()) { focusLog.fine("The window is unmapped, so rejecting the request"); return false; }  if (window3 == window1) { focusLog.fine("Parent window is active - generating focus for this window"); handleWindowFocusInSync(-1L); return true; }  focusLog.fine("Parent window is not active"); XDecoratedPeer xDecoratedPeer = AWTAccessor.getComponentAccessor().<XDecoratedPeer>getPeer(window1); if (xDecoratedPeer != null && xDecoratedPeer.requestWindowFocus(this, paramLong, paramBoolean)) { focusLog.fine("Parent window accepted focus request - generating focus for this window"); return true; }  focusLog.fine("Denied - parent window is not active and didn't accept focus request"); return false; } void setActualFocusedWindow(XWindowPeer paramXWindowPeer) {} private void applyWindowType() { XNETProtocol xNETProtocol = XWM.getWM().getNETProtocol(); if (xNETProtocol == null) return;  XAtom xAtom = null; switch (getWindowType()) { case NORMAL: xAtom = (this.ownerPeer == null) ? xNETProtocol.XA_NET_WM_WINDOW_TYPE_NORMAL : xNETProtocol.XA_NET_WM_WINDOW_TYPE_DIALOG; break;case UTILITY: xAtom = xNETProtocol.XA_NET_WM_WINDOW_TYPE_UTILITY; break;case POPUP: xAtom = xNETProtocol.XA_NET_WM_WINDOW_TYPE_POPUP_MENU; break; }  if (xAtom != null) { XAtomList xAtomList = new XAtomList(); xAtomList.add(xAtom); xNETProtocol.XA_NET_WM_WINDOW_TYPE.setAtomListProperty(getWindow(), xAtomList); } else { xNETProtocol.XA_NET_WM_WINDOW_TYPE.DeleteProperty(getWindow()); }  } public void xSetVisible(boolean paramBoolean) { if (log.isLoggable(PlatformLogger.Level.FINE)) log.fine("Setting visible on " + this + " to " + paramBoolean);  XToolkit.awtLock(); try { this.visible = paramBoolean; if (paramBoolean) { applyWindowType(); XlibWrapper.XMapRaised(XToolkit.getDisplay(), getWindow()); } else { XlibWrapper.XUnmapWindow(XToolkit.getDisplay(), getWindow()); }  XlibWrapper.XFlush(XToolkit.getDisplay()); } finally { XToolkit.awtUnlock(); }  } public void addDropTarget() { XToolkit.awtLock(); try { if (this.dropTargetCount == 0) { long l = getWindow(); if (l != 0L) XDropTargetRegistry.getRegistry().registerDropSite(l);  }  this.dropTargetCount++; } finally { XToolkit.awtUnlock(); }  } public void removeDropTarget() { XToolkit.awtLock(); try { this.dropTargetCount--; if (this.dropTargetCount == 0) { long l = getWindow(); if (l != 0L) XDropTargetRegistry.getRegistry().unregisterDropSite(l);  }  } finally { XToolkit.awtUnlock(); }  } void addRootPropertyEventDispatcher() { if (this.rootPropertyEventDispatcher == null) { this.rootPropertyEventDispatcher = new XEventDispatcher() { public void dispatchEvent(XEvent param1XEvent) { if (param1XEvent.get_type() == 28) XWindowPeer.this.handleRootPropertyNotify(param1XEvent);  } }
/*      */         ; XlibWrapper.XSelectInput(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(), 4194304L); XToolkit.addEventDispatcher(XToolkit.getDefaultRootWindow(), this.rootPropertyEventDispatcher); }  } void removeRootPropertyEventDispatcher() { if (this.rootPropertyEventDispatcher != null) { XToolkit.removeEventDispatcher(XToolkit.getDefaultRootWindow(), this.rootPropertyEventDispatcher); this.rootPropertyEventDispatcher = null; }  } public void updateFocusableWindowState() { this.cachedFocusableWindow = isFocusableWindow(); } public XAtomList getNETWMState() { if (this.net_wm_state == null) this.net_wm_state = this.XA_NET_WM_STATE.getAtomListPropertyList(this);  return this.net_wm_state; } public void setNETWMState(XAtomList paramXAtomList) { this.net_wm_state = paramXAtomList; if (paramXAtomList != null) this.XA_NET_WM_STATE.setAtomListProperty(this, paramXAtomList);  } public PropMwmHints getMWMHints() { if (this.mwm_hints == null) { this.mwm_hints = new PropMwmHints(); if (!XWM.XA_MWM_HINTS.getAtomData(getWindow(), this.mwm_hints.pData, 5)) this.mwm_hints.zero();  }  return this.mwm_hints; } public void setMWMHints(PropMwmHints paramPropMwmHints) { this.mwm_hints = paramPropMwmHints; if (paramPropMwmHints != null) XWM.XA_MWM_HINTS.setAtomData(getWindow(), this.mwm_hints.pData, 5);  } protected void updateDropTarget() { XToolkit.awtLock(); try { if (this.dropTargetCount > 0) { long l = getWindow(); if (l != 0L) { XDropTargetRegistry.getRegistry().unregisterDropSite(l); XDropTargetRegistry.getRegistry().registerDropSite(l); }  }  } finally { XToolkit.awtUnlock(); }  }
/*      */   public void setGrab(boolean paramBoolean) { this.grab = paramBoolean; if (paramBoolean) { this.pressTarget = this; grabInput(); } else { ungrabInput(); }  }
/*      */   public boolean isGrabbed() { return (this.grab && XAwtState.getGrabWindow() == this); }
/*      */   public void handleXCrossingEvent(XEvent paramXEvent) { XCrossingEvent xCrossingEvent = paramXEvent.get_xcrossing(); if (grabLog.isLoggable(PlatformLogger.Level.FINE)) grabLog.fine("{0}, when grabbed {1}, contains {2}", new Object[] { xCrossingEvent, Boolean.valueOf(isGrabbed()), Boolean.valueOf(containsGlobal(xCrossingEvent.get_x_root(), xCrossingEvent.get_y_root())) });  if (isGrabbed()) { XBaseWindow xBaseWindow = XToolkit.windowToXWindow(xCrossingEvent.get_window()); if (grabLog.isLoggable(PlatformLogger.Level.FINER)) grabLog.finer("  -  Grab event target {0}", new Object[] { xBaseWindow });  if (xBaseWindow != null && xBaseWindow != this) { xBaseWindow.dispatchEvent(paramXEvent); return; }  }  super.handleXCrossingEvent(paramXEvent); }
/*      */   public void handleMotionNotify(XEvent paramXEvent) { XMotionEvent xMotionEvent = paramXEvent.get_xmotion(); if (grabLog.isLoggable(PlatformLogger.Level.FINER)) grabLog.finer("{0}, when grabbed {1}, contains {2}", new Object[] { xMotionEvent, Boolean.valueOf(isGrabbed()), Boolean.valueOf(containsGlobal(xMotionEvent.get_x_root(), xMotionEvent.get_y_root())) });  if (isGrabbed()) { boolean bool = false; int i = XToolkit.getNumberOfButtonsForMask(); for (byte b = 0; b < i; b++) { if (b != 4 && b != 5) bool = (bool || (xMotionEvent.get_state() & XlibUtil.getButtonMask(b + 1)) != 0) ? true : false;  }  XBaseWindow xBaseWindow = XToolkit.windowToXWindow(xMotionEvent.get_window()); if (bool && this.pressTarget != xBaseWindow) { xBaseWindow = this.pressTarget.isVisible() ? this.pressTarget : this; xMotionEvent.set_window(xBaseWindow.getWindow()); Point point = xBaseWindow.toLocal(xMotionEvent.get_x_root(), xMotionEvent.get_y_root()); xMotionEvent.set_x(point.x); xMotionEvent.set_y(point.y); }  if (grabLog.isLoggable(PlatformLogger.Level.FINER)) grabLog.finer("  -  Grab event target {0}", new Object[] { xBaseWindow });  if (xBaseWindow != null && xBaseWindow != getContentXWindow() && xBaseWindow != this) { xBaseWindow.dispatchEvent(paramXEvent); return; }  if (!containsGlobal(xMotionEvent.get_x_root(), xMotionEvent.get_y_root()) && !bool) return;  }  super.handleMotionNotify(paramXEvent); }
/* 2322 */   public void setOpacity(float paramFloat) { long l = (long)(paramFloat * 4.2949673E9F);
/* 2323 */     if (l < 0L) {
/* 2324 */       l = 0L;
/*      */     }
/* 2326 */     if (l > 4294967295L) {
/* 2327 */       l = 4294967295L;
/*      */     }
/*      */     
/* 2330 */     XAtom xAtom = XAtom.get("_NET_WM_WINDOW_OPACITY");
/*      */     
/* 2332 */     if (l == 4294967295L) {
/* 2333 */       xAtom.DeleteProperty(getWindow());
/*      */     } else {
/* 2335 */       xAtom.setCard32Property(getWindow(), l);
/*      */     }  }
/*      */ 
/*      */   
/*      */   public void setOpaque(boolean paramBoolean) {}
/*      */   
/*      */   public void updateWindow() {}
/*      */ }


/* Location:              /Users/timmy/timmy/OSWE/oswe/openCRX/rt.jar!/sun/awt/X11/XWindowPeer.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */