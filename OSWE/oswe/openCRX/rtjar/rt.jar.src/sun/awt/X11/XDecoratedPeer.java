/*      */ package sun.awt.X11;
/*      */ 
/*      */ import java.awt.Component;
/*      */ import java.awt.Dimension;
/*      */ import java.awt.Graphics;
/*      */ import java.awt.Insets;
/*      */ import java.awt.Point;
/*      */ import java.awt.Rectangle;
/*      */ import java.awt.Window;
/*      */ import java.awt.event.ComponentEvent;
/*      */ import java.awt.event.InvocationEvent;
/*      */ import java.awt.event.WindowEvent;
/*      */ import java.util.List;
/*      */ import sun.awt.AWTAccessor;
/*      */ import sun.awt.IconInfo;
/*      */ import sun.awt.SunToolkit;
/*      */ import sun.util.logging.PlatformLogger;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ abstract class XDecoratedPeer
/*      */   extends XWindowPeer
/*      */ {
/*   40 */   private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.X11.XDecoratedPeer");
/*   41 */   private static final PlatformLogger insLog = PlatformLogger.getLogger("sun.awt.X11.insets.XDecoratedPeer");
/*   42 */   private static final PlatformLogger focusLog = PlatformLogger.getLogger("sun.awt.X11.focus.XDecoratedPeer");
/*   43 */   private static final PlatformLogger iconLog = PlatformLogger.getLogger("sun.awt.X11.icon.XDecoratedPeer");
/*      */   boolean configure_seen;
/*      */   boolean insets_corrected;
/*      */   XIconWindow iconWindow;
/*      */   WindowDimensions dimensions;
/*      */   XContentWindow content;
/*      */   Insets currentInsets;
/*      */   XFocusProxyWindow focusProxy;
/*      */   private Insets wm_set_insets;
/*      */   long reparent_serial;
/*      */   boolean no_reparent_artifacts;
/*      */   XWindowPeer actualFocusedWindow;
/*      */   
/*      */   XDecoratedPeer(Window paramWindow) {
/*   57 */     super(paramWindow);
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  304 */     this.reparent_serial = 0L;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  665 */     this.no_reparent_artifacts = false;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1176 */     this.actualFocusedWindow = null; } public long getShell() { return this.window; } public long getContentWindow() { return (this.content == null) ? this.window : this.content.getWindow(); } void preInit(XCreateWindowParams paramXCreateWindowParams) { super.preInit(paramXCreateWindowParams); this.winAttr.initialFocus = true; this.currentInsets = new Insets(0, 0, 0, 0); applyGuessedInsets(); Rectangle rectangle = (Rectangle)paramXCreateWindowParams.get("bounds"); this.dimensions = new WindowDimensions(rectangle, getRealInsets(), false); paramXCreateWindowParams.put((K)"bounds", (V)this.dimensions.getClientRect()); if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Initial dimensions {0}", new Object[] { this.dimensions });  Long long_ = (Long)paramXCreateWindowParams.get("event mask"); paramXCreateWindowParams.add("event mask", Long.valueOf(long_.longValue() & 0xFFFFFFFFFFDFFFFCL)); } void postInit(XCreateWindowParams paramXCreateWindowParams) { updateSizeHints(this.dimensions); super.postInit(paramXCreateWindowParams); initResizability(); XWM.requestWMExtents(getWindow()); this.content = XContentWindow.createContent(this); if (this.warningWindow != null) this.warningWindow.toFront();  this.focusProxy = createFocusProxy(); } void setIconHints(List<IconInfo> paramList) { if (!XWM.getWM().setNetWMIcon(this, paramList) && paramList.size() > 0) { if (this.iconWindow == null) this.iconWindow = new XIconWindow(this);  this.iconWindow.setIconImages(paramList); }  } public void updateMinimumSize() { super.updateMinimumSize(); updateMinSizeHints(); } private void updateMinSizeHints() { if (isResizable()) { Dimension dimension = getTargetMinimumSize(); if (dimension != null) { Insets insets = getRealInsets(); int i = dimension.width - insets.left - insets.right; int j = dimension.height - insets.top - insets.bottom; if (i < 0) i = 0;  if (j < 0) j = 0;  setSizeHints(0x10L | (isLocationByPlatform() ? 0L : 5L), getX(), getY(), i, j); if (isVisible()) { Rectangle rectangle = getShellBounds(); int k = (rectangle.width < i) ? i : rectangle.width; int m = (rectangle.height < j) ? j : rectangle.height; if (k != rectangle.width || m != rectangle.height) setShellSize(new Rectangle(0, 0, k, m));  }  } else { boolean bool = isMinSizeSet(); XWM.removeSizeHints(this, 16L); if (bool && isShowing() && XWM.needRemap(this)) { xSetVisible(false); XToolkit.XSync(); xSetVisible(true); }  }  }  } XFocusProxyWindow createFocusProxy() { return new XFocusProxyWindow(this); } protected XAtomList getWMProtocols() { XAtomList xAtomList = super.getWMProtocols(); xAtomList.add(wm_delete_window); xAtomList.add(wm_take_focus); return xAtomList; } public Graphics getGraphics() { AWTAccessor.ComponentAccessor componentAccessor = AWTAccessor.getComponentAccessor(); return getGraphics(this.content.surfaceData, componentAccessor.getForeground(this.target), componentAccessor.getBackground(this.target), componentAccessor.getFont(this.target)); } public void setTitle(String paramString) { if (log.isLoggable(PlatformLogger.Level.FINE)) log.fine("Title is " + paramString);  this.winAttr.title = paramString; updateWMName(); } protected String getWMName() { if (this.winAttr.title == null || this.winAttr.title.trim().equals("")) return " ";  return this.winAttr.title; } void updateWMName() { super.updateWMName(); String str = getWMName(); XToolkit.awtLock(); try { if (str == null || str.trim().equals("")) str = "Java";  XAtom xAtom1 = XAtom.get(37L); xAtom1.setProperty(getWindow(), str); XAtom xAtom2 = XAtom.get("_NET_WM_ICON_NAME"); xAtom2.setPropertyUTF8(getWindow(), str); } finally { XToolkit.awtUnlock(); }  } public void handleIconify() { postEvent(new WindowEvent((Window)this.target, 203)); } public void handleDeiconify() { postEvent(new WindowEvent((Window)this.target, 204)); } public void handleFocusEvent(XEvent paramXEvent) { super.handleFocusEvent(paramXEvent); XFocusChangeEvent xFocusChangeEvent = paramXEvent.get_xfocus(); if (focusLog.isLoggable(PlatformLogger.Level.FINER)) focusLog.finer("Received focus event on shell: " + xFocusChangeEvent);  } protected boolean isInitialReshape() { return false; } private static Insets difference(Insets paramInsets1, Insets paramInsets2) { return new Insets(paramInsets1.top - paramInsets2.top, paramInsets1.left - paramInsets2.left, paramInsets1.bottom - paramInsets2.bottom, paramInsets1.right - paramInsets2.right); } private static boolean isNull(Insets paramInsets) { return (paramInsets == null || (paramInsets.left | paramInsets.top | paramInsets.right | paramInsets.bottom) == 0); } private static Insets copy(Insets paramInsets) { return new Insets(paramInsets.top, paramInsets.left, paramInsets.bottom, paramInsets.right); } private Insets getWMSetInsets(XAtom paramXAtom) { if (isEmbedded()) return null;  if (this.wm_set_insets != null) return this.wm_set_insets;  if (paramXAtom == null) { this.wm_set_insets = XWM.getInsetsFromExtents(getWindow()); } else { this.wm_set_insets = XWM.getInsetsFromProp(getWindow(), paramXAtom); }  if (insLog.isLoggable(PlatformLogger.Level.FINER)) insLog.finer("FRAME_EXTENTS: {0}", new Object[] { this.wm_set_insets });  if (this.wm_set_insets != null) this.wm_set_insets = copy(this.wm_set_insets);  return this.wm_set_insets; } XDecoratedPeer(XCreateWindowParams paramXCreateWindowParams) { super(paramXCreateWindowParams); this.reparent_serial = 0L; this.no_reparent_artifacts = false; this.actualFocusedWindow = null; } private void resetWMSetInsets() { this.wm_set_insets = null; } public void handlePropertyNotify(XEvent paramXEvent) { super.handlePropertyNotify(paramXEvent); XPropertyEvent xPropertyEvent = paramXEvent.get_xproperty(); if (xPropertyEvent.get_atom() == XWM.XA_KDE_NET_WM_FRAME_STRUT.getAtom() || xPropertyEvent.get_atom() == XWM.XA_NET_FRAME_EXTENTS.getAtom()) getWMSetInsets(XAtom.get(xPropertyEvent.get_atom()));  } public void handleReparentNotifyEvent(XEvent paramXEvent) { XReparentEvent xReparentEvent = paramXEvent.get_xreparent(); if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine(xReparentEvent.toString());  this.reparent_serial = xReparentEvent.get_serial(); XToolkit.awtLock(); try { long l = XlibWrapper.RootWindow(XToolkit.getDisplay(), getScreenNumber()); if (isEmbedded()) { setReparented(true); this.insets_corrected = true; return; }  Component component = this.target; if (getDecorations() == XWindowAttributesData.AWT_DECOR_NONE) { setReparented(true); this.insets_corrected = true; reshape(this.dimensions, 2, false); } else if (xReparentEvent.get_parent() == l) { this.configure_seen = false; this.insets_corrected = false; if (isVisible()) { XWM.getWM().unshadeKludge(this); insLog.fine("- WM exited"); } else { insLog.fine(" - reparent due to hide"); }  } else { setReparented(true); this.insets_corrected = false; Insets insets = getWMSetInsets((XAtom)null); if (insets != null) { if (insLog.isLoggable(PlatformLogger.Level.FINER)) insLog.finer("wm-provided insets {0}", new Object[] { insets });  Insets insets1 = this.dimensions.getInsets(); if (insets.equals(insets1)) { insLog.finer("Insets are the same as estimated - no additional reshapes necessary"); this.no_reparent_artifacts = true; this.insets_corrected = true; applyGuessedInsets(); return; }  } else { insets = XWM.getWM().getInsets(this, xReparentEvent.get_window(), xReparentEvent.get_parent()); if (insLog.isLoggable(PlatformLogger.Level.FINER)) if (insets != null) { insLog.finer("correctWM {0}", new Object[] { insets }); } else { insLog.finer("correctWM insets are not available, waiting for configureNotify"); }   }  if (insets != null) handleCorrectInsets(insets);  }  } finally { XToolkit.awtUnlock(); }  } protected void handleCorrectInsets(Insets paramInsets) { XToolkit.awtLock(); try { Insets insets = difference(paramInsets, this.currentInsets); if (insLog.isLoggable(PlatformLogger.Level.FINEST)) insLog.finest("Corrention {0}", new Object[] { insets });  if (!isNull(insets)) { this.currentInsets = copy(paramInsets); applyGuessedInsets(); updateMinSizeHints(); }  if (insLog.isLoggable(PlatformLogger.Level.FINER)) insLog.finer("Dimensions before reparent: " + this.dimensions);  this.dimensions.setInsets(getRealInsets()); this.insets_corrected = true; if (isMaximized()) return;  if ((getHints().get_flags() & 0x5L) != 0L) { reshape(this.dimensions, 3, false); } else { reshape(this.dimensions, 2, false); }  } finally { XToolkit.awtUnlock(); }  } public void handleMoved(WindowDimensions paramWindowDimensions) { Point point = paramWindowDimensions.getLocation(); AWTAccessor.getComponentAccessor().setLocation(this.target, point.x, point.y); postEvent(new ComponentEvent(this.target, 100)); } protected Insets guessInsets() { if (isEmbedded() || isTargetUndecorated()) return new Insets(0, 0, 0, 0);  if (!isNull(this.currentInsets)) return copy(this.currentInsets);  Insets insets = getWMSetInsets((XAtom)null); if (insets == null) insets = XWM.getWM().guessInsets(this);  return insets; } private void applyGuessedInsets() { Insets insets = guessInsets(); this.currentInsets = copy(insets); } public void revalidate() { XToolkit.executeOnEventHandlerThread(this.target, new Runnable() {
/*      */           public void run() { XDecoratedPeer.this.target.invalidate(); XDecoratedPeer.this.target.validate(); }
/* 1178 */         }); } Insets getRealInsets() { if (isNull(this.currentInsets)) applyGuessedInsets();  return this.currentInsets; } public Insets getInsets() { Insets insets = copy(getRealInsets()); insets.top += getMenuBarHeight(); if (insLog.isLoggable(PlatformLogger.Level.FINEST)) insLog.finest("Get insets returns {0}", new Object[] { insets });  return insets; } boolean gravityBug() { return XWM.configureGravityBuggy(); } int getInputMethodHeight() { return 0; } void updateSizeHints(WindowDimensions paramWindowDimensions) { Rectangle rectangle = paramWindowDimensions.getClientRect(); checkShellRect(rectangle); updateSizeHints(rectangle.x, rectangle.y, rectangle.width, rectangle.height); } void updateSizeHints() { updateSizeHints(this.dimensions); } public void reshape(WindowDimensions paramWindowDimensions, int paramInt, boolean paramBoolean) { if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Reshaping " + this + " to " + paramWindowDimensions + " op " + paramInt + " user reshape " + paramBoolean);  if (paramBoolean) { Rectangle rectangle = paramWindowDimensions.getBounds(); Insets insets = paramWindowDimensions.getInsets(); if (paramWindowDimensions.isClientSizeSet()) rectangle = new Rectangle(rectangle.x, rectangle.y, rectangle.width - insets.left - insets.right, rectangle.height - insets.top - insets.bottom);  paramWindowDimensions = new WindowDimensions(rectangle, insets, paramWindowDimensions.isClientSizeSet()); }  XToolkit.awtLock(); try { if (!isReparented() || !isVisible()) { if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("- not reparented({0}) or not visible({1}), default reshape", new Object[] { Boolean.valueOf(isReparented()), Boolean.valueOf(this.visible) });  Point point1 = getLocation(); Point point2 = new Point(AWTAccessor.getComponentAccessor().getX(this.target), AWTAccessor.getComponentAccessor().getY(this.target)); if (!point2.equals(point1)) handleMoved(paramWindowDimensions);  this.dimensions = new WindowDimensions(paramWindowDimensions); updateSizeHints(this.dimensions); Rectangle rectangle1 = this.dimensions.getClientRect(); checkShellRect(rectangle1); setShellBounds(rectangle1); if (this.content != null && !this.content.getSize().equals(paramWindowDimensions.getSize())) reconfigureContentWindow(paramWindowDimensions);  return; }  int i = XWM.getWMID(); updateChildrenSizes(); applyGuessedInsets(); Rectangle rectangle = paramWindowDimensions.getClientRect(); if (gravityBug()) { Insets insets = paramWindowDimensions.getInsets(); rectangle.translate(insets.left, insets.top); }  if ((paramInt & 0x4000) == 0 && isEmbedded()) rectangle.setLocation(0, 0);  checkShellRectSize(rectangle); if (!isEmbedded()) checkShellRectPos(rectangle);  paramInt &= 0xFFFFBFFF; if (paramInt == 1) { setShellPosition(rectangle); } else if (isResizable()) { if (paramInt == 3) { setShellBounds(rectangle); } else { setShellSize(rectangle); }  } else { XWM.setShellNotResizable(this, paramWindowDimensions, rectangle, true); if (paramInt == 3) setShellPosition(rectangle);  }  reconfigureContentWindow(paramWindowDimensions); } finally { XToolkit.awtUnlock(); }  } private void reshape(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, boolean paramBoolean) { Insets insets; boolean bool = false; WindowDimensions windowDimensions = new WindowDimensions(this.dimensions); switch (paramInt5 & 0xFFFFBFFF) { case 1: windowDimensions.setLocation(paramInt1, paramInt2); break;case 2: windowDimensions.setSize(paramInt3, paramInt4); break;case 4: insets = this.currentInsets; paramInt3 -= insets.left + insets.right; paramInt4 -= insets.top + insets.bottom; windowDimensions.setClientSize(paramInt3, paramInt4); break;default: windowDimensions.setLocation(paramInt1, paramInt2); windowDimensions.setSize(paramInt3, paramInt4); break; }  if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("For the operation {0} new dimensions are {1}", new Object[] { operationToString(paramInt5), windowDimensions });  reshape(windowDimensions, paramInt5, paramBoolean); } abstract boolean isTargetUndecorated(); public void setBounds(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) { reshape(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, true); validateSurface(); } void reconfigureContentWindow(WindowDimensions paramWindowDimensions) { if (this.content == null) { insLog.fine("WARNING: Content window is null"); return; }  this.content.setContentBounds(paramWindowDimensions); } public void handleConfigureNotifyEvent(XEvent paramXEvent) { assert SunToolkit.isAWTLockHeldByCurrentThread(); XConfigureEvent xConfigureEvent = paramXEvent.get_xconfigure(); if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Configure notify {0}", new Object[] { xConfigureEvent });  if (isReparented()) this.configure_seen = true;  if (!isMaximized() && (xConfigureEvent.get_serial() == this.reparent_serial || xConfigureEvent.get_window() != getShell()) && !this.no_reparent_artifacts) { insLog.fine("- reparent artifact, skipping"); return; }  this.no_reparent_artifacts = false; if (!isVisible() && XWM.getWMID() != 2) { insLog.fine(" - not visible, skipping"); return; }  int i = XWM.getWMID(); if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("reparented={0}, visible={1}, WM={2}, decorations={3}", new Object[] { Boolean.valueOf(isReparented()), Boolean.valueOf(isVisible()), Integer.valueOf(i), Integer.valueOf(getDecorations()) });  if (!isReparented() && isVisible() && i != 2 && !XWM.isNonReparentingWM() && getDecorations() != XWindowAttributesData.AWT_DECOR_NONE) { insLog.fine("- visible but not reparented, skipping"); return; }  if (!this.insets_corrected && getDecorations() != XWindowAttributesData.AWT_DECOR_NONE) { long l = XlibUtil.getParentWindow(this.window); Insets insets = (l != -1L) ? XWM.getWM().getInsets(this, this.window, l) : null; if (insLog.isLoggable(PlatformLogger.Level.FINER)) if (insets != null) { insLog.finer("Configure notify - insets : " + insets); } else { insLog.finer("Configure notify - insets are still not available"); }   if (insets != null) { handleCorrectInsets(insets); } else { this.insets_corrected = true; }  }  updateChildrenSizes(); Rectangle rectangle = AWTAccessor.getComponentAccessor().getBounds(this.target); Point point1 = getNewLocation(xConfigureEvent, this.currentInsets.left, this.currentInsets.top); WindowDimensions windowDimensions = new WindowDimensions(point1, new Dimension(xConfigureEvent.get_width(), xConfigureEvent.get_height()), copy(this.currentInsets), true); if (insLog.isLoggable(PlatformLogger.Level.FINER)) insLog.finer("Insets are {0}, new dimensions {1}", new Object[] { this.currentInsets, windowDimensions });  checkIfOnNewScreen(windowDimensions.getBounds()); Point point2 = getLocation(); this.dimensions = windowDimensions; if (!point1.equals(point2)) handleMoved(windowDimensions);  reconfigureContentWindow(windowDimensions); updateChildrenSizes(); repositionSecurityWarning(); } void setActualFocusedWindow(XWindowPeer paramXWindowPeer) { synchronized (getStateLock())
/* 1179 */     { this.actualFocusedWindow = paramXWindowPeer; }  } private void checkShellRectSize(Rectangle paramRectangle) { paramRectangle.width = Math.max(1, paramRectangle.width); paramRectangle.height = Math.max(1, paramRectangle.height); } private void checkShellRectPos(Rectangle paramRectangle) { int i = XWM.getWMID(); if ((i == 5 || i == 6) && paramRectangle.x == 0 && paramRectangle.y == 0) paramRectangle.x = paramRectangle.y = 1;  } private void checkShellRect(Rectangle paramRectangle) { checkShellRectSize(paramRectangle); checkShellRectPos(paramRectangle); } public void setShellBounds(Rectangle paramRectangle) { if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Setting shell bounds on " + this + " to " + paramRectangle);  XToolkit.awtLock(); try { updateSizeHints(paramRectangle.x, paramRectangle.y, paramRectangle.width, paramRectangle.height); XlibWrapper.XResizeWindow(XToolkit.getDisplay(), getShell(), paramRectangle.width, paramRectangle.height); XlibWrapper.XMoveWindow(XToolkit.getDisplay(), getShell(), paramRectangle.x, paramRectangle.y); } finally { XToolkit.awtUnlock(); }  } public void setShellSize(Rectangle paramRectangle) { if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Setting shell size on " + this + " to " + paramRectangle);  XToolkit.awtLock(); try { updateSizeHints(paramRectangle.x, paramRectangle.y, paramRectangle.width, paramRectangle.height); XlibWrapper.XResizeWindow(XToolkit.getDisplay(), getShell(), paramRectangle.width, paramRectangle.height); } finally { XToolkit.awtUnlock(); }  } public void setShellPosition(Rectangle paramRectangle) { if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("Setting shell position on " + this + " to " + paramRectangle);  XToolkit.awtLock(); try { updateSizeHints(paramRectangle.x, paramRectangle.y, paramRectangle.width, paramRectangle.height); XlibWrapper.XMoveWindow(XToolkit.getDisplay(), getShell(), paramRectangle.x, paramRectangle.y); } finally { XToolkit.awtUnlock(); }  } void initResizability() { setResizable(this.winAttr.initialResizability); } public void setResizable(boolean paramBoolean) { int i = this.winAttr.functions; if (!isResizable() && paramBoolean) { this.currentInsets = new Insets(0, 0, 0, 0); resetWMSetInsets(); if (!isEmbedded()) setReparented(false);  this.winAttr.isResizable = paramBoolean; if ((i & 0x1) != 0) { i &= 0xFFFFFFED; } else { i |= 0x12; }  this.winAttr.functions = i; XWM.setShellResizable(this); } else if (isResizable() && !paramBoolean) { this.currentInsets = new Insets(0, 0, 0, 0); resetWMSetInsets(); if (!isEmbedded()) setReparented(false);  this.winAttr.isResizable = paramBoolean; if ((i & 0x1) != 0) { i |= 0x12; } else { i &= 0xFFFFFFED; }  this.winAttr.functions = i; XWM.setShellNotResizable(this, this.dimensions, this.dimensions.getBounds(), false); }  } Rectangle getShellBounds() { return this.dimensions.getClientRect(); } public Rectangle getBounds() { return this.dimensions.getBounds(); } public Dimension getSize() { return this.dimensions.getSize(); } public int getX() { return (this.dimensions.getLocation()).x; } public int getY() { return (this.dimensions.getLocation()).y; } public Point getLocation() { return this.dimensions.getLocation(); } public int getAbsoluteX() { return (this.dimensions.getScreenBounds()).x; } public int getAbsoluteY() { return (this.dimensions.getScreenBounds()).y; } public int getWidth() { return (getSize()).width; } public int getHeight() { return (getSize()).height; } public final WindowDimensions getDimensions() { return this.dimensions; } public Point getLocationOnScreen() { XToolkit.awtLock(); try { if (this.configure_seen) return toGlobal(0, 0);  Point point = this.target.getLocation(); if (insLog.isLoggable(PlatformLogger.Level.FINE)) insLog.fine("getLocationOnScreen {0} not reparented: {1} ", new Object[] { this, point });  return point; } finally { XToolkit.awtUnlock(); }  } protected boolean isEventDisabled(XEvent paramXEvent) { switch (paramXEvent.get_type()) { case 22: return true;case 7: case 8: return true; }  return super.isEventDisabled(paramXEvent); } int getDecorations() { return this.winAttr.decorations; } int getFunctions() { return this.winAttr.functions; } public void setVisible(boolean paramBoolean) { if (log.isLoggable(PlatformLogger.Level.FINER)) log.finer("Setting {0} to visible {1}", new Object[] { this, Boolean.valueOf(paramBoolean) });  if (paramBoolean && !isVisible()) { XWM.setShellDecor(this); super.setVisible(paramBoolean); if (this.winAttr.isResizable) { XWM.removeSizeHints(this, 32L); updateMinimumSize(); }  } else { super.setVisible(paramBoolean); }  } protected void suppressWmTakeFocus(boolean paramBoolean) { XAtomList xAtomList = getWMProtocols(); if (paramBoolean) { xAtomList.remove(wm_take_focus); } else { xAtomList.add(wm_take_focus); }  wm_protocols.setAtomListProperty(this, xAtomList); } public void dispose() { if (this.content != null) this.content.destroy();  this.focusProxy.destroy(); if (this.iconWindow != null) this.iconWindow.destroy();  super.dispose(); } public void handleClientMessage(XEvent paramXEvent) { super.handleClientMessage(paramXEvent); XClientMessageEvent xClientMessageEvent = paramXEvent.get_xclient(); if (wm_protocols != null && xClientMessageEvent.get_message_type() == wm_protocols.getAtom()) if (xClientMessageEvent.get_data(0) == wm_delete_window.getAtom()) { handleQuit(); } else if (xClientMessageEvent.get_data(0) == wm_take_focus.getAtom()) { handleWmTakeFocus(xClientMessageEvent); }   } private void handleWmTakeFocus(XClientMessageEvent paramXClientMessageEvent) { if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("WM_TAKE_FOCUS on {0}", new Object[] { this });  requestWindowFocus(paramXClientMessageEvent.get_data(1), true); } protected void requestXFocus(long paramLong, boolean paramBoolean) { if (this.focusProxy == null) { if (focusLog.isLoggable(PlatformLogger.Level.WARNING)) focusLog.warning("Focus proxy is null for " + this);  } else { if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("Requesting focus to proxy: " + this.focusProxy);  if (paramBoolean) { this.focusProxy.xRequestFocus(paramLong); } else { this.focusProxy.xRequestFocus(); }  }  } XFocusProxyWindow getFocusProxy() { return this.focusProxy; } public void handleQuit() { postEvent(new WindowEvent((Window)this.target, 201)); } final void dumpMe() { System.err.println(">>> Peer: " + this.x + ", " + this.y + ", " + this.width + ", " + this.height); } final void dumpTarget() { AWTAccessor.ComponentAccessor componentAccessor = AWTAccessor.getComponentAccessor(); int i = componentAccessor.getWidth(this.target); int j = componentAccessor.getHeight(this.target); int k = componentAccessor.getX(this.target); int m = componentAccessor.getY(this.target); System.err.println(">>> Target: " + k + ", " + m + ", " + i + ", " + j); } final void dumpShell() { dumpWindow("Shell", getShell()); } final void dumpContent() { dumpWindow("Content", getContentWindow()); }
/*      */   final void dumpParent() { long l = XlibUtil.getParentWindow(getShell()); if (l != 0L) { dumpWindow("Parent", l); } else { System.err.println(">>> NO PARENT"); }  }
/*      */   final void dumpWindow(String paramString, long paramLong) { XWindowAttributes xWindowAttributes = new XWindowAttributes(); try { XToolkit.awtLock(); try { int i = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(), paramLong, xWindowAttributes.pData); } finally { XToolkit.awtUnlock(); }  System.err.println(">>>> " + paramString + ": " + xWindowAttributes.get_x() + ", " + xWindowAttributes.get_y() + ", " + xWindowAttributes.get_width() + ", " + xWindowAttributes.get_height()); } finally { xWindowAttributes.dispose(); }  }
/*      */   final void dumpAll() { dumpTarget(); dumpMe(); dumpParent(); dumpShell(); dumpContent(); }
/*      */   boolean isMaximized() { return false; }
/*      */   boolean isOverrideRedirect() { return Window.Type.POPUP.equals(getWindowType()); }
/*      */   public boolean requestWindowFocus(long paramLong, boolean paramBoolean) { focusLog.fine("Request for decorated window focus"); Window window1 = XKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow(); Window window2 = XWindowPeer.getDecoratedOwner(window1); if (focusLog.isLoggable(PlatformLogger.Level.FINER)) focusLog.finer("Current window is: active={0}, focused={1}", new Object[] { Boolean.valueOf((this.target == window2)), Boolean.valueOf((this.target == window1)) });  XWindowPeer xWindowPeer = this; while (xWindowPeer.nextTransientFor != null) xWindowPeer = xWindowPeer.nextTransientFor;  if (xWindowPeer == null || !xWindowPeer.focusAllowedFor()) return false;  if (this == xWindowPeer) { if (isWMStateNetHidden()) { focusLog.fine("The window is unmapped, so rejecting the request"); return false; }  if (this.target == window2 && this.target != window1) { focusLog.fine("Focus is on child window - transferring it back to the owner"); handleWindowFocusInSync(-1L); return true; }  Window window = XWindowPeer.getNativeFocusedWindow(); if (focusLog.isLoggable(PlatformLogger.Level.FINEST)) focusLog.finest("Real native focused window: " + window + "\nKFM's focused window: " + window1);  if (this.target == window && XWM.getWMID() == 11) { if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("The window is already natively focused.");  return true; }  }  if (focusLog.isLoggable(PlatformLogger.Level.FINE)) focusLog.fine("Requesting focus to " + ((this == xWindowPeer) ? "this window" : (String)xWindowPeer));  if (paramBoolean) { xWindowPeer.requestXFocus(paramLong); } else { xWindowPeer.requestXFocus(); }  return (this == xWindowPeer); }
/* 1186 */   boolean requestWindowFocus(XWindowPeer paramXWindowPeer, long paramLong, boolean paramBoolean) { setActualFocusedWindow(paramXWindowPeer);
/* 1187 */     return requestWindowFocus(paramLong, paramBoolean); }
/*      */   
/*      */   public void handleWindowFocusIn(long paramLong) {
/* 1190 */     if (null == this.actualFocusedWindow) {
/* 1191 */       super.handleWindowFocusIn(paramLong);
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     }
/*      */     else {
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1205 */       postEvent(new InvocationEvent(this.target, new Runnable() {
/*      */               public void run() {
/* 1207 */                 XWindowPeer xWindowPeer = null;
/* 1208 */                 synchronized (XDecoratedPeer.this.getStateLock()) {
/* 1209 */                   xWindowPeer = XDecoratedPeer.this.actualFocusedWindow;
/* 1210 */                   XDecoratedPeer.this.actualFocusedWindow = null;
/* 1211 */                   if (null == xWindowPeer || !xWindowPeer.isVisible() || !xWindowPeer.isFocusableWindow()) {
/* 1212 */                     xWindowPeer = XDecoratedPeer.this;
/*      */                   }
/*      */                 } 
/* 1215 */                 xWindowPeer.handleWindowFocusIn_Dispatch();
/*      */               }
/*      */             }));
/*      */     } 
/*      */   }
/*      */   
/*      */   public void handleWindowFocusOut(Window paramWindow, long paramLong) {
/* 1222 */     Window window = XKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow();
/*      */ 
/*      */     
/* 1225 */     if (window != null && window != this.target) {
/* 1226 */       Window window1 = XWindowPeer.getDecoratedOwner(window);
/*      */       
/* 1228 */       if (window1 != null && window1 == this.target) {
/* 1229 */         setActualFocusedWindow(AWTAccessor.getComponentAccessor().<XWindowPeer>getPeer(window));
/*      */       }
/*      */     } 
/* 1232 */     super.handleWindowFocusOut(paramWindow, paramLong);
/*      */   }
/*      */ }


/* Location:              /Users/timmy/timmy/OSWE/oswe/openCRX/rt.jar!/sun/awt/X11/XDecoratedPeer.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */